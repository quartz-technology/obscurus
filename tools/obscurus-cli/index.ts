import * as fs from 'fs';
import { Group } from "@semaphore-protocol/group";
import { Identity } from "@semaphore-protocol/identity";
import { generateProof, type SemaphoreProof } from "@semaphore-protocol/proof";
import { Command } from "commander";
import { Address, createPublicClient, createWalletClient, getContract, Hex, http, publicActions } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { ABI } from "./src/abi";
import { genIdentity, printIdentity, storeIdentity } from "./src/identity";
import { convertSemaphoreProofToABI, decodeProofFromJSON, genProof, printProof, storeProof } from "./src/proof";

/*----------------------------------------------------------------------*/
/*                                                                      */
/*     CLI                                                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

const program = new Command();

program
  .version("0.0.1")
  .description("Obscurus CLI used to generate identity, proof and interact with deployed contracts.")

program
  .command("gen-identity")
  .option("--secret <secret>", "Optional secret value used to generate the identity.")
  .option("--file <file>", "If set, this is the file to store the generated identity into.")
  .option("--verbose", "Whether or not the generated identity should be printed to the stdout.")
  .action(({ secret, file, verbose }: { secret?: string, file?: string, verbose: boolean }) => {
    const identity = genIdentity(secret);

    if (file) {
      storeIdentity(identity, file);
    }

    if (verbose) {
      printIdentity(identity);
    }

    process.exit(0);
  });

program
  .command("gen-local-proof")
  .requiredOption("--prover-private-key <private-key>", "Prover's identity private key.")
  .requiredOption("--identities <identities...>", "Identities to include in the group.")
  .requiredOption("--message <message>", "Message to prove.")
  .requiredOption("--scope <scope>", "Scope used to prevent double signaling.")
  .option("--file <file>", "If set, this is the file to store the generated proof into.")
  .option("--verbose", "Whether or not the generated proof should be printed to the stdout.")
  .action(async ({
    proverPrivateKey,
    identities,
    message,
    scope,
    file,
    verbose
  }: { proverPrivateKey: string, identities: string[], message: bigint, scope: bigint, file?: string, verbose: boolean }) => {
    const proof = await genProof(proverPrivateKey, identities, message, scope);

    if (file) {
      storeProof(proof, file);
    }

    if (verbose) {
      printProof(proof);
    }

    process.exit(0);
  });

program
  .command("gen-remote-proof")
  .requiredOption("--prover-key-file <prover-key-file>", "File where the prover's identity private key is stored.")
  .requiredOption("--identities <identities...>", "Identities to include in the group.")
  .requiredOption("--contract-address <address>", "Address of the Obscurus contract.")
  .requiredOption("--to <to>", "Transaction destination address.")
  .requiredOption("--value <value>", "Transaction value.")
  .requiredOption("--data <data>", "Transaction data.")
  .requiredOption("--operation <operation>", "Transaction operation type.")
  .requiredOption("--file <file>", "The file to store the generated proof into.")
  .option("--rpc-url <rpc-url>", "RPC URL used to query Obscurus data.", "http://localhost:8545")
  .action(async ({ proverKeyFile, identities, contractAddress, rpcUrl, to, value, data, operation, file }: { proverKeyFile: string, identities: string[], contractAddress: Address, to: Address, value: bigint, data: Hex, operation: number, file: string, rpcUrl: string }) => {
    const client = createPublicClient({
      transport: http(rpcUrl),
    })

    const contract = getContract({
      address: contractAddress,
      abi: ABI,
      client: client,
    })

    const signal = await contract.read.computeSignal();
    const scope = await contract.read.computeScope([{
      to,
      value,
      data,
      operation,
    }]);

    const proverIdentity: { privateKey: string } = JSON.parse(fs.readFileSync(proverKeyFile, 'utf8'));

    const identity = Identity.import(proverIdentity.privateKey);

    const group = new Group(identities);
    const encodedMessage = BigInt(signal);

    const proof = await generateProof(identity, group, encodedMessage, scope);

    storeProof(proof, file);

    process.exit(0);
  });

program
  .command("obscure-exec")
  .requiredOption("--tx-signer <private-key>", "Private key of the transaction signer.")
  .requiredOption("--proof-files <files...>", "Files containing the proofs generated by the identities managing the Obscurus module.")
  .requiredOption("--contract-address <address>", "Address of the Obscurus contract.")
  .requiredOption("--to <to>", "Transaction destination address.")
  .requiredOption("--value <value>", "Transaction value.")
  .requiredOption("--data <data>", "Transaction data.")
  .requiredOption("--operation <operation>", "Transaction operation type.")
  .option("--rpc-url <rpc-url>", "RPC URL used to query Obscurus data.", "http://localhost:8545")
  .action(async ({ txSigner, proofFiles, contractAddress, rpcUrl, to, value, data, operation }: { txSigner: Hex, proofFiles: string[], contractAddress: Address, to: Address, value: bigint, data: Hex, operation: number, rpcUrl: string }) => {
    const account = privateKeyToAccount(txSigner);

    const client = createWalletClient({
      account,
      transport: http(rpcUrl),
    }).extend(publicActions)


    const proofs: SemaphoreProof[] = [];

    for (const proofFile of proofFiles) {
      const proof = decodeProofFromJSON(fs.readFileSync(proofFile, 'utf8'));

      proofs.push(proof);
    }

    const { request, result } = await client.simulateContract({
      address: contractAddress,
      abi: ABI,
      functionName: "obscureExecAndReturnData",
      args: [
        {
          txParameters: {
            to,
            value: BigInt(value),
            data,
            operation: Number(operation),
          },
          semaphoreProofs: proofs.map((proof) => {
            return convertSemaphoreProofToABI(proof);
          }),
        }
      ],
      account,
    });

    const hash = await client.writeContract(request);
    await client.waitForTransactionReceipt({ hash });

    console.log(result);

    process.exit(0);
  });

(async () => {
  await program.parseAsync();
})();

